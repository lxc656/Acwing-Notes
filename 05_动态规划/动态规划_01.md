背包问题作为典型的Dp(动态规划)问题，分类如下

01背包问题：每件物品最多只用一次，要么0个，要么1个
完全背包：每件物品有无限个
多重背包：每件物品最多有Si个
分组背包问题：n组物品，每组里面有若干个，每一组里至多只能选一个

Dp问题主要考虑两个问题
1.状态表示： f(i,j)
		状态表示要考虑两方面的问题，分为：
        f(i,j)所表示的集合是什么,在背包问题当中这个集合是在要求条件(有i个物品可选，物品总体积不超过j)下的所有选法
        f(i,j)的数值表示的集合属性是什么(一般来说有三种，集合里面的最大值，最小值，元素的数量，像背包问题就是最大值)

2.状态计算
        把当前集合划分成若干个更小的子集，每一个子集的状态都能算出来，每个集合的状态都能用前面更小的子集的状态表示出来，一定要满足不漏，不重复的原则不一定要所有时候都满足，比如说求最大值重复也无所谓，但是求个数的话就要不重复

​        背包问题当中把f(i,j)的集合划分成了两个子集，也就是说把选法划分成了两大类，一类是选法当中包含第i个物品的，一类是不包含第i个物品的，对于包含第i个物品的集合，把该集合当中的每种选法里的第i个物品都去掉，不影响对于最大值的判断，则转化成了"f(i-1,j-Vi)+Wi"所表示的集合,对于不包含第i个物品的选法的集合，则转化成了f(i-1,j)所表示的集合，最终的f(i,j)的取值是 Max{f(i-1,j),f(i-1,j-Vi)+Wi}

下面的01背包问题的代码进行了二维的动态规划，实现了上面所说的算法思路

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N=1010;

int n,m; //n用来表示所有的物品个数，m来表示所有的物品的总容量上限
int v[N],w[N]; //数组v和w分别表示物品的体积和价值
int f[N][N]; //二维数组f用来表示动态规划当中的状态集合，并且状态f[0][0~m]
             //应该为0，正好这里让二维数组f做全局变量，可以达到这个目的

int main()
{
    cin>>n>>m;

    for(int i=1;i<=n;i++) cin>>v[i]>>w[i];

    for(int i=1;i<=n;i++) //开始计算除了f[0][0~m]以外其他f数组的元素的值
        for(int j=0;j<=m;j++)
        {
            f[i][j] = f[i-1][j];
            if(j>=v[i]) f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]); 
            //上面这一步非常重要，因为可能存在第i个物品的体积大于总体积上限，所以要先判断
        }
    cout<<f[n][m]<<endl;

    return 0;
}
```

上面的代码的算法是在二维空间实现的，其实也可以转成一维的，因为在计算状态时，f[i]这一层的状态只用到了f[i-1]这一层的状态，并且公式f(i,j)=Max{f(i-1,j),f(i-1,j-Vi)+Wi}里面f(i-1,j)和f(i-1,j-Vi)第二个维度的坐标值都不大于j，因为状态计算有这两个特性，所以有如下的代码可以在一维空间进行同样的动态规划，并且使用了滚动数组的思想，这也是01背包问题的终极写法

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N=1010;

int n,m; //n用来表示所有的物品个数，m来表示所有的物品的总容量上限
int v[N],w[N]; //数组v和w分别表示物品的体积和价值
int f[N];
int main()
{
    cin>>n>>m;

    for(int i=1;i<=n;i++) cin>>v[i]>>w[i];

//下面这段是将原代码直接降到一维的结果，可是逻辑上面有一点问题
    /*for(int i=1;i<=n;i++) 
        for(int j=v[i];j<=m;j++) //因为 j<v[i]时无意义,且现在变成了一维，
                                 //二维情况下的 f[i][j] = f[i-1][j]; 这句代码
                                 //降到一维就没有了意义，所以就让j从v[i]开始
        {
            f[j]=max(f[j],f[j-v[i]]+w[i]);
            //二维情况下的代码:f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
            //将二维的情况直接降到一维，应该变成
            //f[j]=max(f[j],f[j-v[i]]+w[i]); j-v[i]小于j，并且j是从小到大枚举的，
            //因此在计算f[j]时,f[j-v[i]]在上一层已经被计算过了(因为正好减去v[i]所以是上一层)，
            //无法实现动态规划中的“拆分成子集然后去考虑”的思想
        }*/
//因此应该这样做
    for(int i=1;i<=n;i++)
        for(int j=m;j>=v[i];j--)
        f[j]=max(f[j],f[j-v[i]]+w[i]); //这样的话，计算f[j]时，f[j-v[i]]还没被计算
    cout<<f[m]<<endl;
    return 0;
}
```

(什么是滚动数组?)

像状态f(i)只由上一层的状态f(i-1)计算出来的这种情况，先用一个二维数组表示所有的状态，f(1)由f(0)计算出来，存储在f(0)的位置，f(2)用f(0)位置的f(1)值算出来，依旧在f(0)所处的位置存储，冲掉f(1)的值，这样只占用了f(0)的空间，算法二维变成一维，这句话非常抽象，我们来结合实际问题看一下，在上面01背包二维转一维的过程中，f(i,j)是由f(i-1,j)和f(i-1,j-v[i])得出的，

![](https://tva1.sinaimg.cn/large/008i3skNly1gu87ybio63j61es0cs40o02.jpg)

如上图所示，蓝色的线代表计算时递推的关系，红色的线表示f(i,j)矩阵同列不同行的元素之间的递推关系，第i行只由第i-1行的数据计算得来，并且第i+1行的数据只需通过第i行计算得来，和第i-1行没有关系，因此我们可以在算法中把状态只用一个一维数组f[j]表示，其本质上就是用数组的第j列存储原来矩阵第j列的数据，听起来很迷惑，数组的一列只够存放一个值，怎么能存储矩阵的列？如上图，将f(i,j)矩阵第i-1行j+v[i]列的值f(i-1,j+v[i+1])存储到数组f[j+v[i]]，之后在f(i,j+v[i+1])被计算出时，将f(i,j+v[i+1])存储到f[j+v[i]]的地址，之前f矩阵的第i-1行的状态就被冲掉了，但第i行的状态全被计算了出来，之后在计算原矩阵第i+1行时，只需要第i行的值，不需要第i-1行的值，因此完全可以用数组f[j]来完成整个动态规划过程的计算

如果看懂了在一维数组中的计算和数据更新的过程，也可以明白一维01背包的代码里为什么要像下面这样

```c++
for(int j=m;j>=v[i];j--)
        f[j]=max(f[j],f[j-v[i]]+w[i]);
```

对j倒序遍历了，如果正序遍历的话，f[j]将最先被更新，存储了第i层的数据，但之后又会用f[j]和f[j+v[i]]进行相当于原先二维dp里的由f(i-1,j)和f(i-1,j+v[i])计算出f(i,j+v[i]),但是此时的f[j]代表了原先第i层(即矩阵的行)的数据，而非第i-1层，就出现了问题，倒序遍历的话，一维数组里每次冲掉的原有数据都是目前还没确定下来的元素里最靠右的元素，该元素不会继续参与数组里其他数据的更新，因此不会错误

Dp优化， 一般来说是对动态规划的代码和计算方程做一个等价变形，我们会在接下来讨论

