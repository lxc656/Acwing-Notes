​		本篇blog继续讲解之前介绍过的dp类型对应的的算法题和解法

​		首先来看下面这个加强版的最长上升子序列问题

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gva7j8bcr5j60vu0rm76502.jpg" style="zoom:33%;" />

这道最长上升子序列的数据范围与上篇bloghttps://zhuanlan.zhihu.com/p/411470225中介绍的最长上升子序列相比，数据范围明显增多，从1k变成了1w，上篇blog中介绍的解法的时间复杂度为O(n^2)，若n为1w就会超时，因此需要给出一个更快速的解法，我们尝试分析一下推导的过程中有没有什么性质，并根据此性质来优化。上篇blog中给出的解法的大致思路如下图

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gva7vwcapbj60ro0a6q4v02.jpg" style="zoom:50%;" />

我们假设一个数组的元素是3 1 2 4 8 5 6，其中3和1本身都可以作为长度为1的最长上升子序列，他们后面的每一个数，如果可以接到3的后面成为一个比之前更长的最长上升子序列，那么也一定可以接到1的后面成为一个比之前更长的最长上升子序列，因此3构成的这个最长上升子序列就没有必要存下来(因为1比3小，可以与更多的数搭配成为比之前更长的上升子序列)，我们求到数组里的第i个数a[i]的最长上升子序列时，它前面的所有上升子序列可以按长度分类，其中长度为1的所有上升子序列里只需要存一个值最小的，长度为2的所有上升子序列里只需要存一个结尾的值最小的，以此类推，我们可以在一个数组p里存储各个长度的上升子序列的最后一个数的值最小是多少，并不断的动态的更新这个数组，可以预感到，上升子序列的长度越大，其结尾元素的最小值(即我们要存储的值)就越大，刚才说的那个数组p呈现单调递增，下面简单证明一下：不妨假设a[i]前面长度为6的上升子序列的结尾最小值<=a[i]前面长度为5的上升子序列的结尾最小值，由于上升子序列本身满足单调递增，因此前面说的长度为6的上升子序列的第5个数比第6个数小，比我们存储的长度为5的上升子序列的结尾最小值还要更小，就产生了矛盾，因此前面所说的单调递增成立

​		基于上面的结论，当我们求以数组元素a[i]为结尾的最长上升子序列时，因为a[i]必须接到所有比a[i]小的数的后面，所以想求最长上升子序列就应该接到小于a[i]的数里最接近a[i]的数的后面，就是要在前面说过数组p里面找到最大的小于a[i]的数(可以用二分查找来做)，这个数在数组p里的下标再加1(p数组供我们使用的元素的下标从1开始)就是要求的最长上升子序列的长度，假设算出来是q,我们之后还要去用a[i]更新一下p[q]的值(刚才的分析得出p[q-1]<a[i]而p[q]>=a[i])，这样的话这个算法的时间复杂度是:上文提到的二分查找的时间复杂度(相比之下忽略更新数据用的时间)O(log n) * n(对数组的n个数都这么做)  ，与最初的O(n^2)相比，效率高了很多(其实这个题的解法更像贪心算法)，代码如下

![](https://tva1.sinaimg.cn/large/008i3skNly1gvabjyvl3pj60u00x2adg02.jpg)

接下来看下一道题-最短编辑距离：

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvac1rdoe3j60k20gyta102.jpg" style="zoom:50%;" />

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvac2kmfqyj60ek0vota602.jpg" style="zoom:50%;" />

这个问题的状态表示和上篇blog的最长公共子序列问题比较接近（btw，“动态规划之所以效率高，是因为它是对暴力搜索的优化，暴力搜索要遍历所有的方案，问题当中所有的方案的总数目过于巨大，一般是指数级别，动态规划可以用一个数来表示一堆东西的最大值，不用朴素地枚举每种方案”——对动态规划的感性理解，y总如是说，这给了笔者一种“大道至简”的感觉，玄之又玄，众妙之门，芜湖）

​		根据一开始讲解动态规划时说到的动态规划最基本的思想，要先完成状态的表示，我们用f[i,j]表示所有将a[1~i]变成b[1~j]的操作方式，f[i,j]的值的属性是所有操作方式的操作次数的最小值，状态计算要分情况讨论，把f[i,j]划分成若干个容易求解的子集，我们纵观之前讲解的这几类动态规划问题的集合划分方式，基本都是根据最后一步的操作的不同来划分子集，这里也是：首先，如果a[i]本来就和b[j]相等，那便转化成求f[i-1,j-1]（一直递归下去直到出现not equal），因此最后一步有如下的操作方式，第一种操作方式是将字符a[i]删掉(假设删掉了a[i]之后a[1~i]完全变成了b[1~j]，那么删之前，a[1~i-1]和b[1~j]匹配，问题就变成了求f[i-1,j]+1)，第二种操作方式是将a[i]加进来(同理，那么添加之前a[1~i]和b[1~j-1]匹配，那便转化成了求f[i,j-1]+1)，第三种操作方式是修改了一个字符(最后一步是把a[i]变成b[j]，那便转化成了求f[i-1,j-1]+1)，所以最终的状态转移方程如下:

f[i,j] = min(f[i-1,j]+1 , f[i,j-1]+1 , f[i-1,j-1]+1 or f[i-1,j-1])

时间复杂度为 状态数 * 计算每个状态需要的时间复杂度 = O(N^2)

代码如下

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvaenmucb8j60ru0vmjtz02.jpg" style="zoom:50%;" />

